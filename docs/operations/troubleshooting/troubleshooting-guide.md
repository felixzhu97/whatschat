# WhatsChat ÊïÖÈöúÊéíÈô§ÊåáÂçó

## üìã Ê¶ÇËø∞

Êú¨ÊåáÂçóÊèê‰æõ WhatsChat È°πÁõÆÂ∏∏ËßÅÈóÆÈ¢òÁöÑËØäÊñ≠ÂíåËß£ÂÜ≥ÊñπÊ°àÔºåÂ∏ÆÂä©ÂºÄÂèëËÄÖÂø´ÈÄüÂÆö‰ΩçÂíå‰øÆÂ§çÈóÆÈ¢ò„ÄÇ

---

## üîç ËØäÊñ≠Â∑•ÂÖ∑

### ÂÅ•Â∫∑Ê£ÄÊü•

```bash
# Ê£ÄÊü•ÊúçÂä°Áä∂ÊÄÅ
curl http://localhost:3001/health

# Ê£ÄÊü•Êï∞ÊçÆÂ∫ìËøûÊé•
curl http://localhost:3001/api/v1/health/database

# Ê£ÄÊü•RedisËøûÊé•
curl http://localhost:3001/api/v1/health/redis

# Ê£ÄÊü•WebSocketËøûÊé•
curl http://localhost:3001/api/v1/health/websocket
```

### Êó•ÂøóÊü•Áúã

```bash
# Êü•ÁúãÂ∫îÁî®Êó•Âøó
tail -f logs/app.log

# Êü•ÁúãÈîôËØØÊó•Âøó
tail -f logs/error.log

# Êü•ÁúãËÆøÈóÆÊó•Âøó
tail -f logs/access.log

# Êü•ÁúãÁâπÂÆöÊó∂Èó¥ÊÆµÁöÑÊó•Âøó
grep "2024-01-01" logs/app.log
```

### Á≥ªÁªüÁõëÊéß

```bash
# Ê£ÄÊü•Á≥ªÁªüËµÑÊ∫ê
htop
df -h
free -h

# Ê£ÄÊü•ÁΩëÁªúËøûÊé•
netstat -tulpn | grep :3001
ss -tulpn | grep :3001

# Ê£ÄÊü•ËøõÁ®ã
ps aux | grep node
```

---

## üö® Â∏∏ËßÅÈóÆÈ¢ò

### 1. Êï∞ÊçÆÂ∫ìËøûÊé•ÈóÆÈ¢ò

#### ÈóÆÈ¢òÁóáÁä∂

- Â∫îÁî®ÂêØÂä®Â§±Ë¥•
- Êï∞ÊçÆÂ∫ìÊü•ËØ¢Ë∂ÖÊó∂
- ËøûÊé•Ê±†ËÄóÂ∞Ω

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•PostgreSQLÊúçÂä°Áä∂ÊÄÅ
sudo systemctl status postgresql

# Ê£ÄÊü•Êï∞ÊçÆÂ∫ìËøûÊé•
psql -h localhost -U whatschat -d whatschat

# Ê£ÄÊü•ËøûÊé•Êï∞
SELECT count(*) FROM pg_stat_activity;

# Ê£ÄÊü•ÈîÅÁ≠âÂæÖ
SELECT * FROM pg_locks WHERE NOT granted;
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// Êï∞ÊçÆÂ∫ìËøûÊé•ÈÖçÁΩÆ‰ºòÂåñ
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  log: ["query", "info", "warn", "error"],
  // ËøûÊé•Ê±†ÈÖçÁΩÆ
  __internal: {
    engine: {
      connectTimeout: 60000,
      queryTimeout: 30000,
      poolTimeout: 30000,
    },
  },
});

// ËøûÊé•ÈáçËØïÊú∫Âà∂
export const connectWithRetry = async (retries = 5) => {
  for (let i = 0; i < retries; i++) {
    try {
      await prisma.$connect();
      console.log("Database connected successfully");
      return;
    } catch (error) {
      console.log(`Database connection attempt ${i + 1} failed:`, error);
      if (i === retries - 1) throw error;
      await new Promise((resolve) => setTimeout(resolve, 2000));
    }
  }
};
```

### 2. RedisËøûÊé•ÈóÆÈ¢ò

#### ÈóÆÈ¢òÁóáÁä∂

- ÁºìÂ≠òÂ§±Êïà
- ‰ºöËØù‰∏¢Â§±
- ÂÆûÊó∂ÂäüËÉΩÂºÇÂ∏∏

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•RedisÊúçÂä°Áä∂ÊÄÅ
sudo systemctl status redis

# ÊµãËØïRedisËøûÊé•
redis-cli ping

# Ê£ÄÊü•RedisÂÜÖÂ≠ò‰ΩøÁî®
redis-cli info memory

# Ê£ÄÊü•RedisËøûÊé•Êï∞
redis-cli info clients
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// RedisËøûÊé•ÈÖçÁΩÆ
const redis = new Redis({
  host: process.env.REDIS_HOST || "localhost",
  port: parseInt(process.env.REDIS_PORT || "6379"),
  maxRetriesPerRequest: 3,
  retryDelayOnFailover: 100,
  enableReadyCheck: false,
  maxLoadingTimeout: 10000,
  lazyConnect: true,
  keepAlive: 30000,
  family: 4,
  db: 0,
  // ËøûÊé•ÈáçËØï
  retryStrategy: (times) => {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
});

// RedisÂÅ•Â∫∑Ê£ÄÊü•
export const checkRedisHealth = async (): Promise<boolean> => {
  try {
    await redis.ping();
    return true;
  } catch (error) {
    console.error("Redis health check failed:", error);
    return false;
  }
};
```

### 3. WebSocketËøûÊé•ÈóÆÈ¢ò

#### ÈóÆÈ¢òÁóáÁä∂

- ÂÆûÊó∂Ê∂àÊÅØ‰∏çÊõ¥Êñ∞
- ËøûÊé•È¢ëÁπÅÊñ≠ÂºÄ
- ÈÄöËØùÂäüËÉΩÂºÇÂ∏∏

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•WebSocketÁ´ØÂè£
netstat -tulpn | grep :3001

# ÊµãËØïWebSocketËøûÊé•
wscat -c ws://localhost:3001/socket.io/

# Ê£ÄÊü•Èò≤ÁÅ´Â¢ôËßÑÂàô
sudo ufw status
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// WebSocketÈÖçÁΩÆ‰ºòÂåñ
const io = new Server(server, {
  cors: {
    origin: process.env.CORS_ORIGIN || "http://localhost:3000",
    methods: ["GET", "POST"],
  },
  pingTimeout: 60000,
  pingInterval: 25000,
  transports: ["websocket", "polling"],
  allowEIO3: true,
});

// ËøûÊé•ÈîôËØØÂ§ÑÁêÜ
io.on("connection", (socket) => {
  socket.on("error", (error) => {
    console.error("Socket error:", error);
  });

  socket.on("disconnect", (reason) => {
    console.log("Socket disconnected:", reason);
  });
});
```

### 4. Êñá‰ª∂‰∏ä‰º†ÈóÆÈ¢ò

#### ÈóÆÈ¢òÁóáÁä∂

- Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•
- Êñá‰ª∂Â§ßÂ∞èÈôêÂà∂
- Êñá‰ª∂Á±ªÂûã‰∏çÊîØÊåÅ

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•‰∏ä‰º†ÁõÆÂΩïÊùÉÈôê
ls -la uploads/
df -h uploads/

# Ê£ÄÊü•Êñá‰ª∂Á±ªÂûã
file uploads/test.jpg

# Ê£ÄÊü•Á£ÅÁõòÁ©∫Èó¥
df -h
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// Êñá‰ª∂‰∏ä‰º†ÈÖçÁΩÆ
const upload = multer({
  dest: "uploads/",
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB
    files: 5,
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|gif|mp4|mp3|pdf|doc|docx/;
    const extname = allowedTypes.test(
      path.extname(file.originalname).toLowerCase()
    );
    const mimetype = allowedTypes.test(file.mimetype);

    if (mimetype && extname) {
      return cb(null, true);
    } else {
      cb(new Error("Invalid file type"));
    }
  },
});

// Êñá‰ª∂È™åËØÅ‰∏≠Èó¥‰ª∂
export const validateFile = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (!req.file) {
    return res.status(400).json({ message: "No file uploaded" });
  }

  // Ê£ÄÊü•Êñá‰ª∂Â§ßÂ∞è
  if (req.file.size > 10 * 1024 * 1024) {
    return res.status(400).json({ message: "File too large" });
  }

  next();
};
```

### 5. ËÆ§ËØÅÈóÆÈ¢ò

#### ÈóÆÈ¢òÁóáÁä∂

- ÁôªÂΩïÂ§±Ë¥•
- ‰ª§ÁâåËøáÊúü
- ÊùÉÈôê‰∏çË∂≥

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•JWTÂØÜÈí•
echo $JWT_SECRET

# ÊµãËØïËÆ§ËØÅAPI
curl -X POST http://localhost:3001/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}'
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// JWTÈÖçÁΩÆÊ£ÄÊü•
export const validateJWTConfig = () => {
  const requiredEnvVars = ["JWT_SECRET", "JWT_REFRESH_SECRET"];

  for (const envVar of requiredEnvVars) {
    if (!process.env[envVar]) {
      throw new Error(`Missing required environment variable: ${envVar}`);
    }
  }

  if (process.env.JWT_SECRET!.length < 32) {
    throw new Error("JWT_SECRET must be at least 32 characters long");
  }
};

// ‰ª§ÁâåÈ™åËØÅ‰∏≠Èó¥‰ª∂
export const authenticateToken = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ message: "Access token required" });
  }

  jwt.verify(token, process.env.JWT_SECRET!, (err, user) => {
    if (err) {
      if (err.name === "TokenExpiredError") {
        return res.status(401).json({ message: "Token expired" });
      }
      return res.status(403).json({ message: "Invalid token" });
    }
    req.user = user;
    next();
  });
};
```

---

## üîß ÊÄßËÉΩÈóÆÈ¢ò

### 1. ÂìçÂ∫îÊó∂Èó¥ÊÖ¢

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•APIÂìçÂ∫îÊó∂Èó¥
curl -w "@curl-format.txt" -o /dev/null -s http://localhost:3001/api/v1/health

# Ê£ÄÊü•Êï∞ÊçÆÂ∫ìÊü•ËØ¢ÊÄßËÉΩ
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';

# Ê£ÄÊü•ÊÖ¢Êü•ËØ¢Êó•Âøó
tail -f logs/slow-queries.log
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// Êï∞ÊçÆÂ∫ìÊü•ËØ¢‰ºòÂåñ
export const getUsersOptimized = async (options: {
  page: number;
  limit: number;
  search?: string;
}) => {
  const { page, limit, search } = options;
  const skip = (page - 1) * limit;

  // ‰ΩøÁî®Á¥¢Âºï‰ºòÂåñÊü•ËØ¢
  const where = search
    ? {
        OR: [
          { username: { contains: search, mode: "insensitive" } },
          { email: { contains: search, mode: "insensitive" } },
        ],
      }
    : {};

  // Âπ∂Ë°åÊü•ËØ¢
  const [users, total] = await Promise.all([
    prisma.user.findMany({
      where,
      skip,
      take: limit,
      select: {
        id: true,
        username: true,
        email: true,
        avatar: true,
        status: true,
      },
      orderBy: { createdAt: "desc" },
    }),
    prisma.user.count({ where }),
  ]);

  return { users, total };
};

// ÁºìÂ≠ò‰ºòÂåñ
export const getCachedUser = async (userId: string) => {
  const cacheKey = `user:${userId}`;

  // ÂÖàÊ£ÄÊü•ÁºìÂ≠ò
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }

  // ‰ªéÊï∞ÊçÆÂ∫ìÊü•ËØ¢
  const user = await prisma.user.findUnique({
    where: { id: userId },
  });

  // ÁºìÂ≠òÁªìÊûú
  if (user) {
    await redis.setex(cacheKey, 300, JSON.stringify(user));
  }

  return user;
};
```

### 2. ÂÜÖÂ≠òÊ≥ÑÊºè

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•ÂÜÖÂ≠ò‰ΩøÁî®
ps aux | grep node
top -p $(pgrep node)

# ÁîüÊàêÂÜÖÂ≠òÂø´ÁÖß
node --inspect app.js
# Âú®Chrome DevTools‰∏≠ÂàÜÊûêÂÜÖÂ≠ò
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// ÂÜÖÂ≠òÊ≥ÑÊºèÈ¢ÑÈò≤
export const cleanupResources = () => {
  // Ê∏ÖÁêÜÂÆöÊó∂Âô®
  const timers = process._getActiveHandles();
  timers.forEach((timer) => {
    if (timer._handle && timer._handle.close) {
      timer._handle.close();
    }
  });

  // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
  process.removeAllListeners();

  // Ê∏ÖÁêÜÊï∞ÊçÆÂ∫ìËøûÊé•
  prisma.$disconnect();

  // Ê∏ÖÁêÜRedisËøûÊé•
  redis.disconnect();
};

// ‰ºòÈõÖÂÖ≥Èó≠
process.on("SIGTERM", () => {
  console.log("SIGTERM received, shutting down gracefully");
  cleanupResources();
  process.exit(0);
});

process.on("SIGINT", () => {
  console.log("SIGINT received, shutting down gracefully");
  cleanupResources();
  process.exit(0);
});
```

---

## üåê ÁΩëÁªúÈóÆÈ¢ò

### 1. CORSÈîôËØØ

#### ÈóÆÈ¢òÁóáÁä∂

- Ë∑®ÂüüËØ∑Ê±ÇÂ§±Ë¥•
- È¢ÑÊ£ÄËØ∑Ê±ÇÂ§±Ë¥•
- ÊµèËßàÂô®ÊéßÂà∂Âè∞CORSÈîôËØØ

#### Ëß£ÂÜ≥ÊñπÊ°à

```typescript
// CORSÈÖçÁΩÆ
const corsOptions = {
  origin: (origin: string | undefined, callback: Function) => {
    const allowedOrigins = [
      "http://localhost:3000",
      "https://app.whatschat.com",
      "https://admin.whatschat.com",
    ];

    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
  exposedHeaders: ["X-Total-Count"],
};

app.use(cors(corsOptions));
```

### 2. ‰ª£ÁêÜÈóÆÈ¢ò

#### ÈóÆÈ¢òÁóáÁä∂

- ËØ∑Ê±ÇË¢´‰ª£ÁêÜÊúçÂä°Âô®Êã¶Êà™
- Ë¥üËΩΩÂùáË°°Âô®ÈÖçÁΩÆÈîôËØØ
- CDNÁºìÂ≠òÈóÆÈ¢ò

#### Ëß£ÂÜ≥ÊñπÊ°à

```nginx
# Nginx‰ª£ÁêÜÈÖçÁΩÆ
upstream backend {
    server whatschat-server:3001;
}

server {
    listen 80;
    server_name api.whatschat.com;

    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocketÊîØÊåÅ
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Ë∂ÖÊó∂ÈÖçÁΩÆ
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
```

---

## üì± ÁßªÂä®Á´ØÈóÆÈ¢ò

### 1. FlutterÂ∫îÁî®ÈóÆÈ¢ò

#### ÈóÆÈ¢òÁóáÁä∂

- Â∫îÁî®Â¥©Ê∫É
- ÁΩëÁªúËØ∑Ê±ÇÂ§±Ë¥•
- Êé®ÈÄÅÈÄöÁü•‰∏çÂ∑•‰Ωú

#### ËØäÊñ≠Ê≠•È™§

```bash
# Ê£ÄÊü•FlutterÁéØÂ¢É
flutter doctor

# Êü•ÁúãÂ∫îÁî®Êó•Âøó
flutter logs

# Ê£ÄÊü•‰æùËµñ
flutter pub deps
```

#### Ëß£ÂÜ≥ÊñπÊ°à

```dart
// ÁΩëÁªúËØ∑Ê±ÇÈîôËØØÂ§ÑÁêÜ
Future<ApiResponse> makeRequest(String url, Map<String, dynamic> data) async {
  try {
    final response = await http.post(
      Uri.parse(url),
      headers: {'Content-Type': 'application/json'},
      body: json.encode(data),
    );

    if (response.statusCode == 200) {
      return ApiResponse.fromJson(json.decode(response.body));
    } else {
      throw ApiException('Request failed with status: ${response.statusCode}');
    }
  } on SocketException {
    throw ApiException('No internet connection');
  } on TimeoutException {
    throw ApiException('Request timeout');
  } catch (e) {
    throw ApiException('Unexpected error: $e');
  }
}

// Êé®ÈÄÅÈÄöÁü•ÈÖçÁΩÆ
class NotificationService {
  static Future<void> initialize() async {
    await Firebase.initializeApp();

    FirebaseMessaging messaging = FirebaseMessaging.instance;

    NotificationSettings settings = await messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
    );

    if (settings.authorizationStatus == AuthorizationStatus.authorized) {
      print('User granted permission');
    }
  }
}
```

---

## üîç Ë∞ÉËØïÊäÄÂ∑ß

### 1. Êó•ÂøóË∞ÉËØï

```typescript
// ÁªìÊûÑÂåñÊó•Âøó
import winston from "winston";

const logger = winston.createLogger({
  level: "debug",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple(),
    }),
    new winston.transports.File({
      filename: "logs/error.log",
      level: "error",
    }),
    new winston.transports.File({
      filename: "logs/combined.log",
    }),
  ],
});

// ‰ΩøÁî®Êó•Âøó
export const logRequest = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;
    logger.info("Request completed", {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      userAgent: req.get("User-Agent"),
      ip: req.ip,
    });
  });

  next();
};
```

### 2. ÊÄßËÉΩÁõëÊéß

```typescript
// ÊÄßËÉΩÁõëÊéß‰∏≠Èó¥‰ª∂
export const performanceMonitor = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const start = process.hrtime();

  res.on("finish", () => {
    const [seconds, nanoseconds] = process.hrtime(start);
    const duration = seconds * 1000 + nanoseconds / 1000000;

    if (duration > 1000) {
      // Ë∂ÖËøá1ÁßíÁöÑËØ∑Ê±Ç
      logger.warn("Slow request detected", {
        method: req.method,
        url: req.url,
        duration: `${duration}ms`,
        memoryUsage: process.memoryUsage(),
      });
    }
  });

  next();
};
```

### 3. ÈîôËØØËøΩË∏™

```typescript
// ÈîôËØØËøΩË∏™‰∏≠Èó¥‰ª∂
export const errorTracker = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  logger.error("Unhandled error", {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    userAgent: req.get("User-Agent"),
    ip: req.ip,
    timestamp: new Date().toISOString(),
  });

  // ÂèëÈÄÅÂà∞ÈîôËØØËøΩË∏™ÊúçÂä°
  if (process.env.SENTRY_DSN) {
    Sentry.captureException(error);
  }

  res.status(500).json({
    success: false,
    message: "Internal server error",
  });
};
```

---

## üìû Ëé∑ÂèñÂ∏ÆÂä©

### 1. Á§æÂå∫ÊîØÊåÅ

- **GitHub Issues**: Êä•ÂëäbugÂíåÂäüËÉΩËØ∑Ê±Ç
- **Discord**: ÂÆûÊó∂ÊäÄÊúØËÆ®ËÆ∫
- **Stack Overflow**: ÊäÄÊúØÈóÆÈ¢òËß£Á≠î

### 2. ÊñáÊ°£ËµÑÊ∫ê

- **APIÊñáÊ°£**: ËØ¶ÁªÜÁöÑAPI‰ΩøÁî®ËØ¥Êòé
- **Êû∂ÊûÑÊñáÊ°£**: Á≥ªÁªüËÆæËÆ°ÂíåÊäÄÊúØÈÄâÂûã
- **ÈÉ®ÁΩ≤ÊåáÂçó**: Áîü‰∫ßÁéØÂ¢ÉÈÉ®ÁΩ≤ËØ¥Êòé

### 3. ËÅîÁ≥ªÊñπÂºè

- **ÈÇÆÁÆ±**: support@whatschat.com
- **GitHub**: https://github.com/whatschat/whatschat
- **ÂÆòÁΩë**: https://whatschat.com

---

## üìö Áõ∏ÂÖ≥ËµÑÊ∫ê

- [Node.jsË∞ÉËØïÊåáÂçó](https://nodejs.org/en/docs/guides/debugging-getting-started/)
- [PostgreSQLÊÄßËÉΩË∞É‰ºò](https://www.postgresql.org/docs/current/performance-tips.html)
- [RedisÊïÖÈöúÊéíÈô§](https://redis.io/docs/manual/troubleshooting/)
- [FlutterË∞ÉËØïÊäÄÂ∑ß](https://docs.flutter.dev/testing/debugging)

---
